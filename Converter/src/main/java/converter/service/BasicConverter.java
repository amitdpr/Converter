package converter.service;

import java.util.Collections;
import java.util.Map;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.logging.Logger;

import converter.config.Config;
import converter.config.Message;
import converter.core.DivisionResult;
import converter.exception.ConversionException;
import converter.helper.HelperService;
import converter.helper.LoggerService;
import converter.util.UtilityService;

/**
 * It is most critical class that represent the flow to calculate Conversion
 * rules. This Class is BasicConverter that perform most of the generic
 * conversion rules and put some place-holder/connector-points to be overridden
 * by its subclass.
 * 
 * @author : amitkumarsingapore@gmail.com Date: Jan 19, 2015
 */
public abstract class BasicConverter implements Converter {

	/**
	 * Resource Bundle to use for all messages and error messages maintained in
	 * resource file(/resources/message.properties)
	 */
	ResourceBundle resource = HelperService
			.getResourceBundle(Config.MessageResourceBundle);
	Logger logger = LoggerService.getLogger(BasicConverter.class);

	/**
	 * This is Sorted Key Set, calculated from operationalUnitMap to perform
	 * greatest divisor calculations.
	 */
	Set<Integer> orderedUnitKeys = Collections.emptySet();

	/**
	 * This is mandatory Key-Value pair units for Converting language. They are
	 * being used to divide the number starting from greatest first and until it
	 * reaches its minimal set.
	 */
	Map<Integer, String> operationalUnitMap = Collections.emptyMap();

	/**
	 * This is Optional in case , there is different logic for
	 * operation(divisor, quotient etc) and display. i.e. for number to word
	 * conversion divisor units are 100, 1000 etc but for conversion quotient
	 * unit selected 2, 13
	 */
	Map<Integer, String> displayUnitMap = Collections.emptyMap();

	/**
	 * During the Initialise within constructor creation in create Ordered Key
	 * set that is further being use din these conversations.
	 */
	void init() {
		orderedUnitKeys = UtilityService.sortDesending(operationalUnitMap);
	}

	/**
	 * Create a constructor with Operational and basic units. It is being used
	 * in WordConverter as they are different in WORD conversion.
	 * 
	 * @param operationalUnitMap
	 *            : KEy-Value pair used for operational i.e. division purpose
	 * @param displayUnitMap
	 *            : Key-Value pair used for representation of quotient, divisor
	 *            etc.
	 */
	BasicConverter(Map<Integer, String> operationalUnitMap,
			Map<Integer, String> displayUnitMap) {
		// This is Mendetory to perform conversion
		this.operationalUnitMap = operationalUnitMap;

		// This is optional and if not given, it will use operationalUnitMap as
		// displayUnitMap
		this.displayUnitMap = displayUnitMap == null
				|| displayUnitMap.isEmpty() ? operationalUnitMap
				: displayUnitMap;

		// Initilize The Required services and Resources
		init();

	}

	/**
	 * Create a constructor with basic units. Same unit/Key-Value pair used for
	 * operational (i.e.)divide and same for display(i.e. converted text). It is
	 * being used in RomanConverter.
	 * 
	 * @param operationalUnitMap
	 *            : Key-Value pair used for operational i.e. division purpose
	 */
	BasicConverter(Map<Integer, String> operationalUnitMap) {
		this(operationalUnitMap, null);
	}

	/**
	 * Every conversation have its fixed set of rules for very initial values
	 * i.e. for zero or for 1 that is minimum unit of conversation. This is
	 * abstraction behaviour to be implemented by sub-class.
	 * 
	 * @param number
	 *            : To be converted to mentioned Number Systems
	 * @param intermediateConversion
	 *            : Flag to represent if it is directly input from user or
	 *            generated by system as intermediately calculations
	 * @return: Converted number in mentioned number system
	 */
	protected abstract String fixedConversion(int number,
			boolean intermediateConversion);

	/*
	 * (non-Javadoc)
	 * 
	 * @see converter.core.Converter#convert(int)
	 */
	public String convert(int number) throws ConversionException {
		String convertedText = "";
		try {
			// Validate Input before processing
			validate(number);

			/*
			 * Pass to recursive service to process conversion Set
			 * intermediateConversion=false As it is processed at root level and
			 * not intermediately.
			 */
			convertedText = convert(number, false);

			// PostConvertion to format additionally not done by auto convert.
			convertedText = postConvert(convertedText);
		} catch (Exception exception) {
			String errorMessage = resource.getString(Message.CONVERTER_ERROR
					.toString()) + exception.getMessage();
			throw new ConversionException(errorMessage, exception);
		}
		return convertedText;
	}

	/**
	 * This Method perform input validations It should be overridden by its
	 * concrete class to put more specific validations.
	 * 
	 * @param number
	 *            : Number to be converted as integer
	 * @return : True if valid number as per Implementing Number System.
	 * @throws ConversionException
	 */
	public void validate(int number) throws ConversionException {
		if (number < Config.MIN_NUMBER_RANGE
				|| number > Config.MAX_NUMBER_RANGE) {
			throw new ConversionException(
					resource.getString(Message.INVALID_RANGE.toString()));
		}
	}

	/**
	 * Convert a number to String representation. It is called as recursively
	 * for intermediately expression calculations. It provides set of required
	 * and optional touch-points to be implemented by subclass base don its
	 * behaviour
	 * 
	 * @param number
	 *            : Input number to be converted to string representation.
	 * @param subsequentConversion
	 *            : Flag to check if called directly or recursively.
	 * @return: String representation implemented/hooked by its subcall class.
	 * @throws ConversionException
	 */
	private String convert(int number, boolean intermediateConversion)
			throws ConversionException {
		String convertedText = new String("");

		// Check for fixedconversion that is pre-calculating values.
		convertedText = fixedConversion(number, intermediateConversion);
		if (!"".equals(convertedText))
			return convertedText;

		/*
		 * Converted in Words for Unit values that are part of predefined values
		 */
		if (displayUnitMap.containsKey(number))
			return displayUnitMap.get(number);

		// Check the Highest divisor from Unit Values.
		/*
		 * It will divide by highest number first and return greatest divisor.
		 * i.e. for WORD conversion million and then thousands and then hundred
		 * for ROMAN conversion X and then V and then i Get Roman Char from
		 * divisor (Max one) i.e. for 6 it will return 5
		 */
		DivisionResult result = getGratestDevisor(number, orderedUnitKeys);

		/*
		 * Process for quotient representation
		 * 
		 * Quotient should append with its Units Value of Divisor i.e. 231=
		 * 231/100 = Divisor=100. Quotient=2 31 reminder In this case Quotient+
		 * UnitValue(Divisor)
		 * 
		 * i.e. For Roman Get The Roman equiv for divisor GreatestDivisor= Roman
		 * Char Quotient=How many time a Roman char repeat Reminder=Remain Value
		 * to be converted in Roman Character
		 */
		convertedText = processQuotientAndDivisor(convertedText,
				result.getQuotient(), result.getDivisor(),
				intermediateConversion);

		// Process for reminder
		convertedText = processReminder(convertedText, result.getReminder(),
				intermediateConversion);

		return convertedText;
	}

	/**
	 * This method combine quotient and divisor to form the number(as per
	 * mentioned number system rule). This is likely to be overridden by
	 * concrete implementation as this logic may differ. RomanConverter complete
	 * override this implementation while WordConverter usages this together
	 * with its Customised implementation.
	 * 
	 * @param convertedText
	 *            : Intermediately text that can be used for internal processing
	 *            to generate new number.
	 * @param quotient
	 *            : quotient of the highest divisor.
	 * @param divisor
	 *            : highest divisor unit
	 * @param intermediateConversion
	 *            : flag to check if called directly(from user input) or
	 *            recursively(from system during generation).
	 * @return : String representation at the end of this phase/method call.
	 * @throws ConversionException
	 *             : If conversion failed.
	 */
	protected String processQuotientAndDivisor(String convertedText,
			int quotient, int divisor, boolean intermediateConversion)
			throws ConversionException {
		convertedText += convert(quotient, true) + getQuotientSeprator()
				+ operationalUnitMap.get(divisor);

		return convertedText;
	}

	/**
	 * It is used to combine quotient with intermediately generated number. To
	 * be implemented by Subclass to provide Numeral System specific Separator.
	 * i.e. for WORD it is "and "
	 * 
	 * @return: Quotient Separator as string
	 */
	protected abstract String getQuotientSeprator();

	/**
	 * It is used to combine reminder-conversion with intermediately generated
	 * number. To be implemented by Subclass to provide Numeral System specific
	 * Separator. i.e. for WORD it is space " "
	 * 
	 * @return: Reminder Separator as string
	 */
	protected abstract String getReminderSeprator();

	/**
	 * This method provided service to perform after the conversion completion.
	 * i.e. reformatting the number trimming the expression etc.
	 * 
	 * @param convertedText
	 *            : Intermediately text that can be used for internal processing
	 *            to generate new number.
	 * @return: Final representation of number.
	 */
	protected String postConvert(String convertedText) {
		/*
		 * One Blank Space coming post number. Remove all blanks from both side
		 * of number representation.
		 */

		return convertedText.trim();
	}

	/**
	 * This method process further to convert reminder (after division) to its
	 * mentioned number system. Once completed it append to intermediately
	 * generated number.
	 * 
	 * @param convertedText
	 *            : Intermediately text that can be used for internal processing
	 *            to generate new number.
	 * @param reminder
	 *            : Integer reminder after dividing number by greatest divisor.
	 * @param intermediateConversion
	 *            : flag to check if called directly(from user input) or
	 *            recursively(from system during generation).
	 * @return : String representation at the end of this phase/method call.
	 * @throws ConversionException
	 *             : If conversion failed.
	 */
	protected String processReminder(String convertedText, int reminder,
			boolean intermediateConversion) throws ConversionException {
		convertedText += getReminderSeprator() + convert(reminder, true);
		return convertedText;
	}

	/**
	 * This method calculate the greatest divisor from the UnitMap and represent
	 * its result in DivisionResult type.
	 * 
	 * @param dividend
	 *            : The number to be divided. It is either actual number
	 *            requested by user or intimidate number generated in previous
	 *            recursion phase of number system generation using divide
	 *            algorithm.
	 * @param unitKeys
	 *            : Operational keys for numeral system , to be used for
	 *            division algorithm for number conversation.
	 * @return : Division Result that is representation of quotient, divisor,
	 *         greatest divisor
	 */
	private DivisionResult getGratestDevisor(int dividend, Set<Integer> unitKeys) {
		DivisionResult result = null;
		int quotient = -1;
		int rem = -1;

		for (Integer unit : unitKeys) {
			// Get the Reminder and quotient

			// Take lower value in case values like 1.2, 1.9, 2.2,2.9
			quotient = new Double(Math.floor(dividend / unit)).intValue();// Check
			// if
			// Round
			// values
			rem = dividend % unit;
			// Quotient is eqiv to ROman char repeated for conversion. That is
			// max of 3
			if (divisionCriteriaMatch(unit, quotient, rem)) {
				result = new DivisionResult(unit, quotient, rem);
				break;

			}
		}

		return result;
	}

	/**
	 * This method validate Unit conversion rule i.e. Divisor, quotient and
	 * reminder. Subclass can customise it accordingly numeral system.
	 * 
	 * @param unit
	 *            : Greatest Divisor or unit. i.e. Number=12, unit=10
	 * @param quotient
	 *            : Quotient after division to number by unit or divisor i.e.
	 *            Number=12, unit=10, Quotient=1
	 * @param rem
	 *            : Reminder after division to number by unit or divisor i.e.
	 *            Number=12, unit=10, Reminder=2
	 * @return true if if rule (applied by implementing class) is accepted
	 */
	protected abstract boolean divisionCriteriaMatch(Integer unit,
			int quotient, int rem);
}
